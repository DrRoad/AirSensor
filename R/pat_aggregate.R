#' @keywords pa_timeseries
#' @export
#' @importFrom rlang .data
#' @importFrom stats aggregate median na.omit quantile sd t.test time
#'
#' @title Aggregation statistics for PurpleAir Timeseries objects
#' 
#' @param pat PurpleAir Timeseries \emph{pat} object.
#' @param FUN The function to be applied to each vector of numeric \code{pat} data.
#' @param ... (Optional) Additional arguments for \code{FUN}.
#' 
#' @description Calculates statistics associated with the aggregation of raw 
#' PurpleAir Timeseries data onto a regular time axis.
#' 
#' Temporal aggregation involves creating time period bins defined by
#' \code{period} and then calculating the statistics associated with the raw
#' data measurements that fall within each bin. The result is a dataframe with
#' a regular time axis and multiple columns of output for every column of
#' input.
#' 
#' 
#' FUN is found by a call to match.fun and typically is specified as a function or a symbol (e.g., a backquoted name) or a character string specifying a function to be searched for from the environment of the call to
#' 
#' 
#' Each of the \emph{pat} object data columns will result in the following
#' basic statistics:
#' 
#' \enumerate{
#' \item{\code{mean}}
#' \item{\code{median}}
#' \item{\code{sd}}
#' \item{\code{min}}
#' \item{\code{max}}
#' \item{\code{count}}
#' }
#' 
#' For the paired \code{pm25_A} and \code{pm25_B} data columns, the following 
#' additional statistics are generated by applying a two-sample t-test to the 
#' A and B channel data in each bin:
#' 
#' \enumerate{
#' \item{\code{pm25_t} -- t-test statistic}
#' \item{\code{pm25_p} -- p-value}
#' \item{\code{pm25_df} -- degrees of freedom}
#' }
#' 
#' These statistics are used to assign aggregate (hourly) values, (\emph{e.g.}
#' \code{temperature_mean}). They can also be used to invalidate some aggregate 
#' values based on \code{sd}, \code{count} or \code{pm25_t}.
#' 
#' @return Returns a dataframe with aggregation statistics.
#' 
#' @examples
#' \dontrun{
#' avg_pat <- pat_aggregate(pat, mean, na.rm = TRUE)
#' }
#' 

pat_aggregate <- function(
  pat, 
  FUN = mean, 
  ...
) {
  
  # ----- Validate parameters --------------------------------------------------
  
  MazamaCoreUtils::stopIfNull(pat)
  
  if ( !pat_isPat(pat) )
    stop("Parameter 'pat' is not a valid 'pa_timeseries' object.")
  
  if ( pat_isEmpty(pat) )
    stop("Parameter 'pat' has no data.")
  
  # Remove any duplicate data records
  pat <- pat_distinct(pat)
  
  # ----- Aggregate Data -------------------------------------------------------
  
  # Only use numeric columns for aggregation matrix
  numeric_cols <- which(unlist(lapply(pat$data, is.numeric)) )
  
  # Convert to eXtensible Time Series (xts) data.frame
  # Separate only useful data for calculation (i.e. only numeric)
  df <- xts::xts(
    x = pat$data[numeric_cols], 
    order.by = pat$data$datetime, 
    unique = TRUE, 
    tzone = 'UTC'
  )
  
  # Split the xts into list of hourly binned data.frames 
  df_hr <- xts::split.xts(df, f = 'hours', drop = FALSE)
  
  # Align the binned data frames to its rounded next hour period (60 * 60 sec)
  # Get the first index of aligned time for future use.
  datetime <- as.numeric(
    lapply(
      X = df_hr, 
      FUN = function(x) zoo::index(xts::align.time(x, 60*60))[1]
    )
  )
  # Convert saved datetime vector back to posix* from int
  class(datetime) <- c("POSIXct", "POSIXt")
  attr(datetime, 'tzone') <- 'UTC'
  
  # Map each binned hourly data.frame to the user defined anonymous 
  # function f applied via apply to each vector in the mapped data.frame
  mapped <- Map( 
    df_hr, 
    f = function(x, f = FUN) {
      apply(
        X = x, 
        MARGIN = 2, 
        FUN = function(x_, ...) { f(x_, ...) }
      )
    }
  )
  
  # Add the rbind mapped data back to the pat object to preserve flexibility 
  # and consistency among the package. 
  pat$data <- data.frame(
    'datetime' = datetime, 
    do.call(rbind, mapped), 
    'datetime_A' = datetime, 
    'datetime_B' = datetime
  )
  
  # Return 
  return(pat)
}
