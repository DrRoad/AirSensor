---
title: "Writing Custom Quality Control Algorithms"
author: "Mazama Science"
date: "2020-05-01"
output: html_document
---

Data quality-control is the process of flagging or removing, either manually or 
algorithmically, invalid or noise data points from a data set. There are many 
statistical techniques and methods to preform quality-control, and in this 
article we will provide a general overview of how to construct such algorithms 
intended for use within the **AirSensor** package. Our goal is to write custom 
quality-control functions that replace, flag, and or remove invalid data points.
Data that are out of an instrument's specifications, that appear to be 
associated with random noise or are associated with other known issues can be 
considered invalid.

NOTE: If you haven't yet read the _Writing Custom Aggregation Functions_ article, 
it is suggested in order to understand advanced `pat_aggregate()` usage.

#### Non-aggregate Multi-plot

### Example 1
#### Minimum Count Quality-control

Let's start by creating a simple quality-control algorithm that aggregates the 
data to an hourly count of the number of data entries within an hour. If the 
count of entries is too low, we will replace the aggregate data with `NA` because 
we cannot trust aggregate data of too few points, otherwise we will return the 
hourly average value.

```{r}
library(AirSensor)
library(dplyr)

# Load a pat
pat <- example_pat

counter_qc <- function(pat, minCount = 11) {

  # Create mean hourly aggregate pat
  mean_pat <- pat_aggregate(pat, function(x) mean(x, na.rm = TRUE))

  # Create count of non-missing pat data
  count_pat <- pat_aggregate(pat, function(x) length(na.omit(x)))

  # Create a minimum count mask
  pm25_A_mask <- count_pat$data$pm25_A < minCount
  pm25_B_mask <- count_pat$data$pm25_B < minCount

  ##################
  # dplyr/tidyverse version
  ##################
  #pat <- mean_pat
  # mean_pat$data <-
  #   mean_pat$data %>%
  #   mutate(pm25_A = replace(.data$pm25_A, pm25_A_mask, NA)) %>%
  #   mutate(pm25_B = replace(.data$pm25_B, pm25_B_mask, NA)) %>%
  #   mutate(hr_count_pm25_A = count_pat$data$pm25_A) %>%
  #   mutate(hr_count_pm25_B = count_pat$data$pm25_B)
  # pat <- mean_pat

  ##################
  # base R version
  ##################
  pat <- mean_pat
  pat$data$pm25_A[pm25_A_mask] <- NA
  pat$data$pm25_B[pm25_B_mask] <- NA
  pat$data$hr_count_pm25_A <- count_pat$data$pm25_A
  pat$data$hr_count_pm25_B <- count_pat$data$pm25_B

  return(pat)
}

qced_pat1 <- counter_qc(pat)
# qced_pat1 <- counter_qc(pat, minCount = 42)
# timeseriesTbl_multiPlot(qced_pat1$data, pattern = "pm25_[AB]")

```

In the code above, we calculate the aggregate hourly average `pat` PM2.5 values, 
`mean_pat`, and the count aggregate `pat` data, `count_pat`. We use the count 
mask to and flag values that are below our minimum count of values `minCount = 21`. 
We can use those flags to replace our hourly average with `NA` that are below 
our `minCount`. We also create two columns in the `pat` data, `hr_count_pm25_A` 
and `hr_count_pm25_B` that capture the hour-binned count.

### Example 2
#### Z-score Filter Quality-control

We can also construct more complex quality control that utilizes features of 
`pat_aggregate()` and other advanced techniques.

Below is an example of using an anonymous function `pat_aggregate()` is provided 
to calculate the 20-minute period Z-score of `pat` data. If the Z-score is below 
our `0.05` threshold, we replace it with `NA`. The data is then re-aggregated to 
an 1-hour average and returned. Effectively, this quality-control function is a 
basic two-tailed Z-score filter that only aggregates data if the it is within 
the p-value (0.05).

```{r}

z_score_qc <- function(pat) {

  pat_z_scored_20min_avg <- pat_aggregate(
    pat,
    function(x) {
      # Caluclate x z-scores
      z_score <- scale(na.omit(x))# (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)

      # Create z-score mask -
      # flag the z-scores who are out of the 5% and 95% quantile range
      z_mask <- pnorm(-abs(z_score)) < 0.05
      x[z_mask] <- NA

      # Calculate the 20-min average values without the flagged data
      y <- mean(x, na.rm = TRUE)
      return(y)
    },
    unit = 'minutes',
    count = 20
  )

  # Re-aggregate to an 1-hour average of the data
  pat <- pat_aggregate(pat_z_scored_20min_avg)

  return(pat)

}

qced_pat2 <- z_score_qc(pat)

```

There are many ways to construct effective quality-control and the examples 
above illustrate just a couple of methods for writing quality-control algorithms. 
The flexibility of creating quality-control algorithms and the use of the
`pat_aggregate()` function allows the user to control numerous statistical 
methods and techniques to construct their own custom functions best suited for 
their use-case.

